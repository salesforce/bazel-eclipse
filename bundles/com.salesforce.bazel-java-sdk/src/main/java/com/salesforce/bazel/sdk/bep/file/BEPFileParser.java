package com.salesforce.bazel.sdk.bep.file;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.salesforce.bazel.sdk.bep.BazelBuildEventTypeManager;
import com.salesforce.bazel.sdk.bep.event.BEPEvent;
import com.salesforce.bazel.sdk.bep.event.BEPStartedEvent;
import com.salesforce.bazel.sdk.logging.LogHelper;

/**
 * Model of a Build Event Protocol (BEP) json file. This file contains the ongoing build events generated by a build or
 * test operation in Bazel.
 * <p>
 * To enable BEP in your workspace, add this to your .bazelrc: build --build_event_json_file bep_build.json test
 * --build_event_json_file bep_test.json Now, whenever you build, Bazel will stream build/test events to those files.
 * <p>
 * BEP is strangely difficult to parse. The contents of the json attributes are denormalized and not fit for computer
 * consumption.
 * <p>
 * <a href="https://docs.bazel.build/versions/master/build-event-protocol.html">BEP Documentation</a>
 */
public class BEPFileParser {
    static final LogHelper LOG = LogHelper.log(BEPFileParser.class);

    private final File bepFile;

    // since it is common to want to see the errors in a build, we always populate the list
    private final List<BEPEvent> errorEvents = new ArrayList<>();

    /**
     * Creates the BazelBuildEventsFile for a File. Note that the File may not exist. This can happen if this
     * configuration happens prior to a build with the configuration setting enabled.
     */
    public BEPFileParser(File bepFile) {
        this.bepFile = bepFile;
    }

    /**
     * Reads the BEP json file, and returns a results object with the parsed events.
     */
    public BEPFileContents readEvents(String callerForLog, BEPFileContents previousContents) {

        BEPFileContents result = new BEPFileContents();
        int eventIndex = 0;

        if (!bepFile.exists()) {
            LOG.debug(callerForLog + ": BEP file " + bepFile.getAbsolutePath() + " does not exist.");
            return result;
        }

        if (bepFile.length() < 100) {
            // typically, this is a zero length file which happens soon after a build starts (Bazel truncates the file)
            // if there are less than 100 bytes in the file, it means there isn't anything interesting to look at yet
            // so just cut off our processing early
            LOG.debug(callerForLog + ": Halting processing of BEP file " + bepFile.getAbsolutePath()
                    + " because it has a short length of [" + bepFile.length() + "] bytes.");
            return result;
        }

        // we will determine if this is the same build as the last polling interval; if so we will
        // build on the work there, and not resend same events to subscribers
        boolean isContinuation = false;

        try (BufferedReader b = new BufferedReader(new FileReader(bepFile))) {
            String eventString = "";
            BEPEvent event = null;

            LOG.info(callerForLog + ": Reading " + bepFile.getAbsolutePath());

            while ((eventString = b.readLine()) != null) {
                LOG.debug("BEP EVENT: {}", eventString);

                if (isContinuation && (eventIndex < previousContents.events.size())) {
                    event = previousContents.events.get(eventIndex);

                    result.events.add(event);
                    eventIndex++;
                    continue;
                }

                event = BazelBuildEventTypeManager.parseEvent(eventString, eventIndex);
                if (event != null) {

                    if (BEPStartedEvent.NAME.equals(event.getEventType())) {
                        // started event is handled differently
                        BEPStartedEvent currentStartEvent = (BEPStartedEvent) event;
                        BEPStartedEvent previousStartEvent =
                                previousContents != null ? previousContents.startedEvent : null;
                        if ((previousStartEvent != null) && (previousContents.startedEvent
                                .getStartTimeMillis() == currentStartEvent.getStartTimeMillis())) {
                            // this is the same build we were looking at last time, this will enable us to optimize parsing
                            // and retain the history so we don't resend the same event more than once to subscribers
                            isContinuation = true;
                            result.startedEvent = previousStartEvent;
                            result.events.add(previousStartEvent);
                        } else {
                            // this is a new build, so ignore previous state
                            result.startedEvent = currentStartEvent;
                            result.events.add(currentStartEvent);
                        }
                    } else {
                        // otherwise all other events are just added
                        result.events.add(event);
                    }
                    eventIndex++;

                    if (event.isError()) {
                        errorEvents.add(event);
                    }
                    if (event.isLastMessage()) {
                        result.hasLastEvent = true;
                    }
                }
            }
        } catch (IOException e) {
            LOG.error("error reading BEP events file [{}]", e, bepFile.getAbsolutePath());
            return result;
        }
        return result;
    }

    public List<BEPEvent> getBuildErrorEvents() {
        return errorEvents;
    }

    // simple manual test client
    public static void main(String[] args) {
        File bepFile = new File("/tmp/bep_build_success.json");
        BEPFileParser bazelEventsFile = new BEPFileParser(bepFile);

        BEPFileContents result = bazelEventsFile.readEvents("testapp", null);

        for (BEPEvent event : result.events) {
            LOG.info(event.toString());
        }
    }
}
